# SOHAM DE
# CS 1104 : Discrete Mathematics, Ashoka University, Spring 2020
# CHECKING FOR ADVANCED CASE ALGORITHM IMPLEMENTATION

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# Important Functions Used:

# (1) chessToGraph(): Converts the chessboard into a bipartite graph, as an adjacency list
# (2) simple_powerSet(): This function is written by myself and generates power sets of the input list, by repeated iteration, and appending a new element every time. This can handle input sizes of upto 5 x 5.
# (3) powerSet(): This function is copied from StackOverflow (url: https://stackoverflow.com/a/1482322) only for testing the maximum input size feasible with a faster power set generator. This can handle input sizes upto 6 x 7 
# (4) collectiveNeighbours(): Calculates the union of all the neighbours of each of the nodes in the input list, using the set data structure in python, and returns the final list of collective neighbours (defined in Project Report).
# (5) color() : Returns 1 if the node passed to it is black. Returns -1 if it is white


# ////////////////////////////////////////////////////////////////////////////////////////////////////

# Important Variables Used:

# (1) chessboard : Stores the index of each square, using standard chess notation (top-left: ‘a8’, bottom-right: ‘h1’)
# (2) row : length of rows of chessboard
# (3) col : length of columns of chessboard
# (4) sum : Stores the sum of all cells in remaining chessboard, with black = 1 and white = -1
# (5) graph{} : An adjacency list, with key-value pairs, as generated by chessToGraph()
# (6) powerset_black_nodes[] : A list of power sets of the current black node

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# INPUT:

# String of algebraic index of square you want to remove. Enter. Press 'y' to continue, 'n' to stop.
# Sample Input : "a3", 'y', "b4", ’y’, “c1”, ‘n’

# OUTPUT:

# 'YES' or 'NO'
# Sample Output : 'NO'

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# IMPORTANT INFORMATION:

# This program involves a Power Set generation, because of which it suffers a bottleneck. It’s runtime complexity is O(2^n^2), where n is the length of the chessboard.
# This program only implements a check, not the tiling
# Using simple_powerSet(), it can handle input sizes of upto 5 X 5
# Using powerSet(), it can handle input sizes of upto 6 X 7

# ////////////////////////////////////////////////////////////////////////////////////////////////////

import time

# ///////////////////////////// Functions List /////////////////////////////

def printboard(): # This function prints the chessboard
    for i in range(row):
        for j in range(col):
            print(chessboard[i][j], end=" ")
        print()

def omit(cell):
    for i in range(row):
        for j in range(col):
            if chessboard[i][j] == cell:
                chessboard[i][j] = "00"

def chessToGraph(): # Converts the Chessboard into a Bipartite Graph, stores as an Adjacency List in a dictionary

    bipartite_graph = {}  # this is a dictionary
    # bipartite_graph['a8'] = {'a7', 'b8'}  # {} denotes a set

    for i in range(row):


        for j in range(col):

            if chessboard[i][j]!= '00':

                neighbours = set()  # this is a set

                if j > 0 and chessboard[i][j - 1]!='00':
                    neighbours.add(chessboard[i][j - 1])

                if j < col-1 and chessboard[i][j + 1]!='00':
                    neighbours.add(chessboard[i][j + 1])

                if i > 0 and chessboard[i - 1][j]!='00':
                    neighbours.add(chessboard[i - 1][j])

                if i < row-1 and chessboard[i + 1][j]!='00':
                    neighbours.add(chessboard[i + 1][j])

                bipartite_graph[chessboard[i][j]] = neighbours
                del neighbours



    return bipartite_graph

def powerSet(list): # taken from https://stackoverflow.com/a/1482322 (NOT MY CODE, not used in program)
    # NOT USED IN ACTUAL PROGRAM
    #ONLY FOR TESTING

    if len(list) <= 1:
        yield list
        yield []
    else:
        for item in powerSet(list[1:]):
            yield [list[0]]+item
            yield item

def simple_powerSet(black_nodes): # THIS is the powerset generator that is called.
  current_powerset=[[]]

  for i in black_nodes:

    for j in current_powerset:

      current_powerset = current_powerset + [list(j)+[i]]

  return current_powerset

def collectiveNeighbours(list_of_black_nodes): # Calculates the union of all neighbours of every node in input list
    total_neighbours = set()
    for i in range(0, len(list_of_black_nodes)):
        total_neighbours = total_neighbours.union(graph[list_of_black_nodes[i]])
    return total_neighbours


def color(cell): # Returns 1 if black, -1 if white
    c = 0
    for i in range(0, row):
        if cell in chessboard[i]:
            c = i + chessboard[i].index(cell)
            if c%2 == 1:
                return 1
            else:
                return -1


# ///////////////////////////// Chessboard naming convention in a 2D matrix /////////////////////////////

row = 4   # any value from 1 to 6 complexity is O(2^(n^2)), sorry :(
col = 4

letters = ['a','b','c','d','e','f','g','h']
chessboard = [[  letters[j]+str(i+1)  for j in range(col)] for i in range(row-1, -1, -1)] # generates chessboard

printboard()

cont = 'y'

while cont =='y':
    toOmit = input("Enter cell to omit: ")
    omit(toOmit) # omits selected nodes
    cont = input("Do you want to continue (y/n): ")

printboard()

sum = 0
for i in range(row):
    for j in range(col):
        if chessboard[i][j]!='00':
            sum = sum + color(chessboard[i][j])

if sum != 0 :  # If the number of remaining white and black nodes aren't equal
    print("NO")
else:         # If the number of remaining white and black nodes are equal

    graph = chessToGraph()

    print(graph)

    black_nodes = set()

    for i in range(row):
        for j in range(col):
            if (i+j)%2 == 1 and chessboard[i][j]!='00':
                black_nodes.add(chessboard[i][j])

    start = time.time() # Calculates time required for powerset generation

    #powerset_black_nodes = [x for x in powerSet(list(black_nodes))] # Using external function
    powerset_black_nodes = simple_powerSet(list(black_nodes)) # Using original function

    powerset_black_nodes.sort()


    print()

    end = time.time()

    print(f"Total Time to computer Powerset: {end - start}")
    num_black = 0
    num_white = 0
    flag = 0

    for i in range(1, len(powerset_black_nodes)):
        num_black = len(powerset_black_nodes[i])  # counts number of black nodes in current subset
        num_white = len(collectiveNeighbours(powerset_black_nodes[i])) # counts number of collective neighbours of current subset


        if num_black > num_white:  # Applies Hall's Theorem
            flag = 1


    if flag == 0:
        print("YES")
    else:
        print("NO")






