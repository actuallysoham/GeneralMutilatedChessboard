# SOHAM DE
# CS 1104 : Discrete Mathematics, Ashoka University, Spring 2020
# MATCHING/ TILING ALGORITHM IMPLEMENTATION

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# Important Functions Used:

# (1) chessToGraph(): Converts the chessboard into a bipartite graph, as an adjacency list
# (2) match(): A recursive backtracking function that takes the index of a black node as input, and generates a list of dominoes, denoted by their starting and ending indexes
# (3) validate(): Returns true if current white node has not been already used in the solution set, else false

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# Important Variables Used:

# (1) chessboard : Stores the index of each square, using standard chess notation (top-left: ‘a8’, bottom-right: ‘h1’)
# (2) algebraic_to_indices{} : Coverts standard chess notation to index notation  (‘a8’ —> ‘1 1’, ‘h1’ —>’8 8’)
# (3) indices_to_algebraic{} : Coverts index notation to standard chess notation (‘1 1’ —> ‘a8’, ‘8 8’ —>’h1’)
# (4) graph{} : An adjacency list, with key-value pairs, as generated by chessToGraph()
# (5) solution[] : A list of 2-tuples, each representing a domino, with it’s starting and ending index

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# INPUT:

# String of index of square you want to remove. Enter. Press 'y' to continue, 'n' to stop.
# Sample Input : "2 4", 'y', "2 5", 'n'

# OUTPUT:

# A list of 2-tuples, with starting and ending vertices of each domino used.
# Sample Output : [['1 2', '1 3'], ['1 4', '1 5'], ['1 6', '1 7'], ['1 8', '2 8'], ...  ['8 5', '7 5'], ['8 7', '8 8']]

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# IMPORTANT INFORMATION:

# This program doesn't implement a check.
# Input must be valid (combination of squares removed must be such that the remaining is coverable).
# The check is implement in a separate module.

# ////////////////////////////////////////////////////////////////////////////////////////////////////

# ////////////////////////// Function List ///////////////////////////

def chessToGraph(): # Converts the chessboard into a bipartite graph, as an adjacency list

    bipartite_graph = {}  # this is a dictionary
    # bipartite_graph['a8'] = ['a7', 'b8']  # [] denotes a list

    for i in range(row):


        for j in range(col):

            if chessboard[i][j]!= '00':

                neighbours = set()  # this is a set

                if j > 0 and chessboard[i][j - 1]!='00':
                    neighbours.add(chessboard[i][j - 1])

                if j < col-1 and chessboard[i][j + 1]!='00':
                    neighbours.add(chessboard[i][j + 1])

                if i > 0 and chessboard[i - 1][j]!='00':
                    neighbours.add(chessboard[i - 1][j])

                if i < row-1 and chessboard[i + 1][j]!='00':
                    neighbours.add(chessboard[i + 1][j])

                bipartite_graph[chessboard[i][j]] = list(neighbours) # saved as a list in graph
                del neighbours

    return bipartite_graph

def omit(cell): # Removes selected cell from chessboard
    for i in range(row):
        for j in range(col):
            if chessboard[i][j] == cell:
                chessboard[i][j] = "00"


def validate(white_node): # Returns true if current white node has not been already used in the solution set, else false
    if white_node in selected_white_nodes:
        return False
    return True

def printboard():
    for i in range(row):
        for j in range(col):
            print(chessboard[i][j], end=" ")
        print()


def match(b_index):   # A recursive backtracking function that takes the index of a black node as input, and generates a list of dominoes, denoted by their starting and ending indexes
# Explained in detail, in Project Report
    count = 0

    for j in range(0, len(graph[black_nodes[b_index]]) ):
        if validate(graph[black_nodes[b_index]][j]):
            count = count + 1

    if count == 0:

        return False # create base case 1: no white neighbours left


    if(b_index == len(black_nodes) - 1): # black_nodes[b_index] is the last node
        for k in range(0, len(graph[black_nodes[b_index]]) - 1):
            if validate(graph[black_nodes[b_index]][k]):
                solution.append([black_nodes[b_index], graph[black_nodes[b_index]][k]])
                return True # create base case 2: on completing all black nodes

        return False

    for i in range(0, len(graph[black_nodes[b_index]])):

        current_white_neighbour = graph[black_nodes[b_index]][i]

        if validate(graph[black_nodes[b_index]][i]): # check if white neighbour has been selected

            solution.append([black_nodes[b_index], current_white_neighbour])

            selected_white_nodes.add(graph[black_nodes[b_index]][i])

            if match(b_index + 1): # recurse to next black_node

                return True


            solution.remove([black_nodes[b_index], current_white_neighbour]) # back-tracking
            selected_white_nodes.remove(graph[black_nodes[b_index]][i])  # restore white neighbour



def convert_to_indices(solution):
    newsolution=[]
    for i in range(len(solution)):
        newsolution.append([algebraic_to_indices[solution[i][0]], algebraic_to_indices[solution[i][1]]])
    return newsolution


# /////////////////////////// Execution Starts Here //////////////////////////

row = 8
col = 8

letters = ['a','b','c','d','e','f','g','h']
chessboard = [[  letters[j]+str(i+1)  for j in range(col)] for i in range(row-1, -1, -1)] # Generates Chessboard

algebraic_to_indices = {} # Used for interconversion of nomenclature styles
indices_to_algebraic = {} # Used for interconversion of nomenclature styles



for i in range(row):
    for j in range(col):
        algebraic_to_indices[chessboard[i][j]] = str(i+1) + " " + str(j+1)
        indices_to_algebraic[str(i+1) + " " + str(j+1)] = chessboard[i][j]


cont = 'y'
toOmit = []

while cont =='y':
    toOmit.append(input("Enter cell to omit: "))
    cont = input("Do you want to continue (y/n): ")

for i in range(0, len(toOmit)):
    omit(indices_to_algebraic[toOmit[i]])  # Removal of seletec nodes

printboard()
graph = chessToGraph() # conversion of Chessboard into a Graph


black_nodes = [] # contains list of all black nodes
index_counter = [0]*len(black_nodes) # stores index of the neighbour of the node included in current matching
selected_white_nodes = set() # stores all white notes which are included in the current matching
b_index = 0 # stores index of current black node
solution = [] # stores 2-tuples of dominoes.

# white neighbours of a black node = graph(black_node)

for i in range(row):
    for j in range(col):
        if (i + j) % 2 == 1 and chessboard[i][j] != '00':
            black_nodes.append(chessboard[i][j])

match(0) # Actual tiling happens here. The index of first black node is passed


print(convert_to_indices(solution))
print(f"Number of dominoes required is: {len(solution)}")


